# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2024-2026 David Kleinhans, Jade University of Applied Sciences
"""
Django settings for ITSM Service Catalogue project.

Configuration is handled via environment variables for flexibility and security.
All sensitive values must be provided through environment variables.

Environment Variables:
- DJANGO_ENV: 'production' or 'development' (default: 'development')
  
  Development mode (DJANGO_ENV=development):
    • DEBUG: Defaults to True (can be overridden with DEBUG env var)
    • Authentication: Django ModelBackend (standard login)
    • Security cookies: Not required to be secure
  
  Production mode (DJANGO_ENV=production):
    • DEBUG: Defaults to False (can be overridden with DEBUG env var)
    • Authentication: Keycloak SSO via OAuth2-proxy (upstream authentication)
    • Security cookies: Secure, HTTPS-only
    • Upstream proxy handles authentication (nginx + OAuth2-proxy + Keycloak)

- DEBUG: Enable debug mode (default: False in production, True in development)
- DJANGO_SECRET_KEY: Secret key (required, auto-generated by entrypoint.sh)
- ALLOWED_HOSTS: Comma-separated list of allowed hosts
- CSRF_TRUSTED_ORIGINS: Comma-separated list of trusted origins
- DB_HOST, DB_PORT, POSTGRES_DATABASE, POSTGRES_USER, POSTGRES_PASSWORD
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Environment configuration
DJANGO_ENV = os.getenv('DJANGO_ENV', 'development')
IS_PRODUCTION = DJANGO_ENV == 'production'

# Security settings
DEBUG = os.getenv('DEBUG', 'False' if IS_PRODUCTION else 'True').lower() in ('true', '1', 'yes')

# Secret key - read from environment or file (for debugging in shell)
SECRET_KEY = os.getenv('DJANGO_SECRET_KEY', '')
if not SECRET_KEY:
    # Try to read from the secret key file (useful for manage.py shell debugging)
    secret_key_file = os.getenv('SECRET_KEY_FILE', '/secrets/django_secret_key')
    try:
        with open(secret_key_file, 'r') as f:
            SECRET_KEY = f.read().strip()
    except (FileNotFoundError, PermissionError):
        raise ValueError(
            f"SECRET_KEY not found. The secret key must be either:\n"
            f"  1. Set in DJANGO_SECRET_KEY environment variable (set by entrypoint.sh), or\n"
            f"  2. Available in {secret_key_file} file"
        )

# Hosts and security
ALLOWED_HOSTS = os.getenv('ALLOWED_HOSTS', '').split(',')
CSRF_TRUSTED_ORIGINS = os.getenv('CSRF_TRUSTED_ORIGINS', '').split(',')

# Production-specific security settings
if IS_PRODUCTION:
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True

# Application definition
INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'modeltranslation',
    'django.contrib.admin',
    'simple_history',
    'ServiceCatalogue',
    'django.contrib.postgres',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
#    'django.contrib.auth.middleware.RemoteUserMiddleware',  # Must come after AuthenticationMiddleware
    'itsm_config.backends.CustomRemoteUserMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.locale.LocaleMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'simple_history.middleware.HistoryRequestMiddleware',
]

ROOT_URLCONF = 'itsm_config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
    {
        'NAME': 'tex',
        'BACKEND': 'django_tex.engine.TeXEngine',
        'APP_DIRS': True,
    },
]

WSGI_APPLICATION = 'itsm_config.wsgi.application'

# Database
# Credentials are configured in docker-compose.yml
# PostgreSQL runs on internal Docker network only (not exposed externally)
# Current password is secure for Docker network isolation
# Use a strong password if running PostgreSQL outside Docker network
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'HOST': os.environ.get('DB_HOST', 'localhost'),
        'PORT': os.environ.get('DB_PORT', '5432'),
        'NAME': os.environ.get('POSTGRES_DATABASE', 'itsm'),
        'USER': os.environ.get('POSTGRES_USER', 'itsm_user'),
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD', 'changeme'),
    }
}

# Caching
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'my_cache_table',
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Internationalization
LANGUAGE_CODE = 'en'
LANGUAGES = [
    ('de', 'Deutsch'),
    ('en', 'English'),
]
TIME_ZONE = 'UTC'
MODELTRANSLATION_FALLBACK_LANGUAGES = ('de', 'en',)
USE_I18N = True
USE_TZ = True

# Static files
STATIC_URL = '/static/'
# Static files are collected outside the app directory to avoid clutter
STATIC_ROOT = '/var/www/staticfiles'
# Additional directories to collect static files from
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
    os.path.join(BASE_DIR, 'user_files', 'static'),
]

# Organization branding and contact
ORGANIZATION_NAME = os.getenv('ORGANIZATION_NAME', 'Your Organization')
ORGANIZATION_ACRONYM = os.getenv('ORGANIZATION_ACRONYM', 'ORG')
HELPDESK_EMAIL = os.getenv('HELPDESK_EMAIL', 'helpdesk@example.com')
HELPDESK_PHONE = os.getenv('HELPDESK_PHONE', '')

# =============================================================================
# Application Metadata & Licensing (Apache-2.0)
# =============================================================================
# This project is licensed under the Apache License, Version 2.0.
# See LICENSE and NOTICE files for details.
#
# ATTRIBUTION REQUEST (Not legally required, but greatly appreciated):
# -----------------------------------------------------------------------
# While Apache-2.0 does not require visible attribution in web deployments,
# we kindly ask that you:
#
#   1. Keep "Powered by scView" visible in the footer with a link to the
#      project repository. This helps others discover the project!
#
#   2. Consider contributing improvements back to the project. Your changes
#      could benefit many other organizations.
#
#   3. Let us know about your deployment - we'd love to hear how scView
#      is being used and learn from your experience!
#
# These values are intentionally hardcoded (not configurable via environment)
# to preserve attribution. We appreciate you keeping them intact!
#
# Thank you for supporting open source software!
# -----------------------------------------------------------------------

# TODO: Update APP_URL with actual GitHub repository URL when published
APP_NAME = 'scView'  # Service Catalogue Viewer - please keep this name
APP_VERSION = '0.4'
APP_COPYRIGHT = 'Jade Hochschule, David Kleinhans'  # Please preserve attribution
APP_URL = 'https://github.com/YOURUSERNAME/scView'  # TODO: Update repository URL
APP_LICENSE = 'Apache-2.0'  # License displayed in footer

# Corporate Identity
PRIMARY_COLOR = os.getenv('PRIMARY_COLOR', '0d6efd')  # Default Bootstrap blue
SECONDARY_COLOR = os.getenv('SECONDARY_COLOR', '6610f2')  # Default Bootstrap indigo
LOGO_FILENAME = os.getenv('LOGO_FILENAME', 'logo.png')

# LaTeX configuration
LATEX_INTERPRETER = 'latexmk -pdf'
# LaTeX graphics paths for logos and templates
LATEX_GRAPHICSPATH = [
    '/app/user_files/static/logos',  # Logos for web and PDF (mounted from project root)
    '/app/user_files/latex_templates',  # LaTeX-specific templates and graphics
]

# Logging
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'WARNING',
    },
}

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# =============================================================================
# AUTHENTICATION CONFIGURATION - Keycloak via OAuth2-proxy
# =============================================================================
# Production uses upstream authentication (nginx + OAuth2-proxy + Keycloak).
# The upstream proxy handles authentication and passes user info via headers:
#   - X-Remote-User: Keycloak username (unique identifier)
#   - X-Remote-Email: Keycloak email address
#
# RemoteUserMiddleware reads these headers and authenticates the user.
# KeycloakRemoteUserBackend automatically creates users and populates email.
#
# See: docs/LOGIN_FLOW.md for detailed documentation

if IS_PRODUCTION:
    # Production uses RemoteUserBackend (trust upstream proxy authentication)
    AUTHENTICATION_BACKENDS = [
        'itsm_config.backends.KeycloakRemoteUserBackend',  # Custom backend with email support
        'django.contrib.auth.backends.ModelBackend',       # Fallback for Django sessions/admin
    ]
    
    # SSO login endpoint - nginx adds X-Remote-User header here after Keycloak auth
    LOGIN_URL = '/sso-login/'
    LOGIN_REDIRECT_URL = '/'
    LOGOUT_REDIRECT_URL = '/oauth2/sign_out'  # Logout from OAuth2-proxy
    
    # Header configuration - tells RemoteUserMiddleware which header to trust
    # This header is set by nginx from OAuth2-proxy's X-Auth-Request-User
    REMOTE_USER_HEADER = 'HTTP_X_REMOTE_USER'
    REMOTE_USER_CREATE_UNKNOWN_USER = True
    
else:
    # Development uses simple ModelBackend (standard Django authentication)
    AUTHENTICATION_BACKENDS = [
        'django.contrib.auth.backends.ModelBackend',
    ]
    
    # Use Django admin login directly in development
    # Avoids /sso-login/ which may be intercepted by proxy
    LOGIN_URL = '/admin/login/'
    LOGIN_REDIRECT_URL = '/'
    LOGOUT_REDIRECT_URL = '/'


# =============================================================================
# Service Catalogue Field Visibility Configuration
# =============================================================================
# Control which ServiceRevision fields are displayed in the application.
# Setting a field to False hides it from:
# - Django admin interface
# - Detail and list views (templates)
# - XLSX exports
# - PDF exports  
# - Fulltext search indexing
# Note: Deactivating fields does not affect the database or stored values.

# Enable/disable 'keywords' field (search keywords not visible to users)
SERVICECATALOGUE_FIELD_KEYWORDS = os.getenv('SERVICECATALOGUE_FIELD_KEYWORDS', 'True').lower() in ('true', '1', 'yes')

# Enable/disable 'requirements' field (requirements for service use)
SERVICECATALOGUE_FIELD_REQUIREMENTS = os.getenv('SERVICECATALOGUE_FIELD_REQUIREMENTS', 'True').lower() in ('true', '1', 'yes')

# Enable/disable 'usage_information' field (important notices for users)
SERVICECATALOGUE_FIELD_USAGE_INFORMATION = os.getenv('SERVICECATALOGUE_FIELD_USAGE_INFORMATION', 'True').lower() in ('true', '1', 'yes')

# Enable/disable 'details' field (detailed service description and notes)
SERVICECATALOGUE_FIELD_DETAILS = os.getenv('SERVICECATALOGUE_FIELD_DETAILS', 'True').lower() in ('true', '1', 'yes')

# Enable/disable 'options' field (available service options)
SERVICECATALOGUE_FIELD_OPTIONS = os.getenv('SERVICECATALOGUE_FIELD_OPTIONS', 'True').lower() in ('true', '1', 'yes')

# Enable/disable 'service_level' field (SLA, availability, support hours)
SERVICECATALOGUE_FIELD_SERVICE_LEVEL = os.getenv('SERVICECATALOGUE_FIELD_SERVICE_LEVEL', 'False').lower() in ('true', '1', 'yes')


# AI-Assisted Service Search Configuration
# ==========================================
# This feature uses AI to help users find relevant IT services from the catalogue.
# It employs a two-step process: initial problem evaluation and detailed service analysis.
#
# IMPORTANT SECURITY CONSIDERATIONS:
# - User queries and AI responses are NOT logged (privacy protection)
# - Only metadata is logged: requested/recommended services, token usage, timestamps
# - Consider information security and data protection regulations when enabling AI features
# - Recommended: Use KISSKI AI (University of Göttingen) or similar privacy-respecting services
#
# For KISSKI AI setup:
# - API URL: https://api.kisski.de/v1 (or your institution's endpoint)
# - Obtain API credentials from your KISSKI administrator
# - KISSKI uses OpenAI-compatible API format
#
# Note: AI responses depend on the quality of service descriptions in your catalogue.
#
# Testing & Debugging:
#   Run: python manage.py test_ai_search
#   This command checks configuration, network connectivity, and API authentication
#   Use --verbose flag for detailed request/response information

# Enable/disable AI-assisted search feature
AI_SEARCH_ENABLED = os.getenv('AI_SEARCH_ENABLED', 'False').lower() in ('true', '1', 'yes')

# AI API endpoint URL (OpenAI-compatible format)
# Provide the base URL only - /chat/completions is automatically appended
# Example for KISSKI: https://chat-ai.academiccloud.de/v1
AI_SEARCH_API_URL = os.getenv('AI_SEARCH_API_URL', None)

# AI API authentication key
AI_SEARCH_API_KEY = os.getenv('AI_SEARCH_API_KEY', None)

# AI model to use (KISSKI models: deepseek-r1, qwen3-235b-a22b, mistral-large-instruct, llama-3.3-70b-instruct, etc.)
# deepseek-r1 is recommended as it's a reasoning model optimized for understanding and analysis
AI_SEARCH_MODEL = os.getenv('AI_SEARCH_MODEL', 'deepseek-r1')

# Timeout for AI API requests in seconds (default: 180 = 3 minutes)
AI_SEARCH_TIMEOUT = int(os.getenv('AI_SEARCH_TIMEOUT', '180'))

# Data protection statement for AI search (optional, displayed to users)
# Inform users about AI provider, model, data handling, etc.
AI_SEARCH_DATA_PROTECTION_STATEMENT_EN = os.getenv('AI_SEARCH_DATA_PROTECTION_STATEMENT_EN', '')
AI_SEARCH_DATA_PROTECTION_STATEMENT_DE = os.getenv('AI_SEARCH_DATA_PROTECTION_STATEMENT_DE', '')


# =============================================================================
# View Access Control Configuration
# =============================================================================
# Control which views require authentication. This allows organizations to
# customize the public/protected boundary of their service catalogue.
#
# Note: Internal views (available, upcoming, retired, under revision) and
# Django admin always require authentication regardless of these settings.
#
# ONLINE_SERVICES_REQUIRE_LOGIN: Online Services landing page (/sc/)
#   Default: False (public) - Quick links to online services are publicly accessible
#   Set to True if you want to require login even for the landing page
#
# SERVICE_CATALOGUE_REQUIRE_LOGIN: Service Catalogue and Service Details
#   Applies to: /sc/services/ (list view) and /sc/service/<id>/ (detail view)
#   Default: True (protected) - Users must login to browse the catalogue and view details
#   Set to False if you want the catalogue and service details to be publicly accessible
#
# AI_SEARCH_REQUIRE_LOGIN: AI-Assisted Search (/sc/ai-search/)
#   Default: True (protected) - Users must login to use AI search
#   Set to False if you want AI search to be publicly accessible
#   Note: This only applies if AI_SEARCH_ENABLED is True

ONLINE_SERVICES_REQUIRE_LOGIN = os.getenv('ONLINE_SERVICES_REQUIRE_LOGIN', 'False').lower() in ('true', '1', 'yes')
SERVICE_CATALOGUE_REQUIRE_LOGIN = os.getenv('SERVICE_CATALOGUE_REQUIRE_LOGIN', 'True').lower() in ('true', '1', 'yes')
AI_SEARCH_REQUIRE_LOGIN = os.getenv('AI_SEARCH_REQUIRE_LOGIN', 'True').lower() in ('true', '1', 'yes')
